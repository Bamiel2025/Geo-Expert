{"ast":null,"code":"import quickselect from 'quickselect';\nexport default class RBush {\n  constructor() {\n    let maxEntries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(bbox) {\n    let node = this.data;\n    const result = [];\n    if (!intersects(bbox, node)) return result;\n    const toBBox = this.toBBox;\n    const nodesToSearch = [];\n    while (node) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const childBBox = node.leaf ? toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return result;\n  }\n  collides(bbox) {\n    let node = this.data;\n    if (!intersects(bbox, node)) return false;\n    const nodesToSearch = [];\n    while (node) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const childBBox = node.leaf ? this.toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return false;\n  }\n  load(data) {\n    if (!(data && data.length)) return this;\n    if (data.length < this._minEntries) {\n      for (let i = 0; i < data.length; i++) {\n        this.insert(data[i]);\n      }\n      return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    let node = this._build(data.slice(), 0, data.length - 1, 0);\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        const tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      }\n\n      // insert the small tree into the large tree at appropriate level\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n    return this;\n  }\n  insert(item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  }\n  clear() {\n    this.data = createNode([]);\n    return this;\n  }\n  remove(item, equalsFn) {\n    if (!item) return this;\n    let node = this.data;\n    const bbox = this.toBBox(item);\n    const path = [];\n    const indexes = [];\n    let i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n      if (node.leaf) {\n        // check current node\n        const index = findItem(item, node.children, equalsFn);\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n          this._condense(path);\n          return this;\n        }\n      }\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n    }\n    return this;\n  }\n  toBBox(item) {\n    return item;\n  }\n  compareMinX(a, b) {\n    return a.minX - b.minX;\n  }\n  compareMinY(a, b) {\n    return a.minY - b.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(data) {\n    this.data = data;\n    return this;\n  }\n  _all(node, result) {\n    const nodesToSearch = [];\n    while (node) {\n      if (node.leaf) result.push(...node.children);else nodesToSearch.push(...node.children);\n      node = nodesToSearch.pop();\n    }\n    return result;\n  }\n  _build(items, left, right, height) {\n    const N = right - left + 1;\n    let M = this._maxEntries;\n    let node;\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M));\n\n      // target number of root entries to maximize storage utilization\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    const N2 = Math.ceil(N / M);\n    const N1 = N2 * Math.ceil(Math.sqrt(M));\n    multiSelect(items, left, right, N1, this.compareMinX);\n    for (let i = left; i <= right; i += N1) {\n      const right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n      for (let j = i; j <= right2; j += N2) {\n        const right3 = Math.min(j + N2 - 1, right2);\n\n        // pack each entry recursively\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n    calcBBox(node, this.toBBox);\n    return node;\n  }\n  _chooseSubtree(bbox, node, level, path) {\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      let minArea = Infinity;\n      let minEnlargement = Infinity;\n      let targetNode;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const area = bboxArea(child);\n        const enlargement = enlargedArea(bbox, child) - area;\n\n        // choose entry with the least area enlargement\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n      node = targetNode || node.children[0];\n    }\n    return node;\n  }\n  _insert(item, level, isNode) {\n    const bbox = isNode ? item : this.toBBox(item);\n    const insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n        level--;\n      } else break;\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  }\n\n  // split overflowed node into two\n  _split(insertPath, level) {\n    const node = insertPath[level];\n    const M = node.children.length;\n    const m = this._minEntries;\n    this._chooseSplitAxis(node, m, M);\n    const splitIndex = this._chooseSplitIndex(node, m, M);\n    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  }\n  _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(node, m, M) {\n    let index;\n    let minOverlap = Infinity;\n    let minArea = Infinity;\n    for (let i = m; i <= M - m; i++) {\n      const bbox1 = distBBox(node, 0, i, this.toBBox);\n      const bbox2 = distBBox(node, i, M, this.toBBox);\n      const overlap = intersectionArea(bbox1, bbox2);\n      const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n      // choose distribution with minimum overlap\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n    return index || M - m;\n  }\n\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(node, m, M) {\n    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    const xMargin = this._allDistMargin(node, m, M, compareMinX);\n    const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  }\n\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    const toBBox = this.toBBox;\n    const leftBBox = distBBox(node, 0, m, toBBox);\n    const rightBBox = distBBox(node, M - m, M, toBBox);\n    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n    for (let i = m; i < M - m; i++) {\n      const child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n    for (let i = M - m - 1; i >= m; i--) {\n      const child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n    return margin;\n  }\n  _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (let i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  }\n  _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (let i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  }\n}\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n  for (let i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n  return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n  for (let i = k; i < p; i++) {\n    const child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n  return destNode;\n}\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\nfunction intersectionArea(a, b) {\n  const minX = Math.max(a.minX, b.minX);\n  const minY = Math.max(a.minY, b.minY);\n  const maxX = Math.min(a.maxX, b.maxX);\n  const maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\nfunction createNode(children) {\n  return {\n    children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n  const stack = [left, right];\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    const mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}","map":{"version":3,"names":["quickselect","RBush","constructor","maxEntries","arguments","length","undefined","_maxEntries","Math","max","_minEntries","ceil","clear","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","i","children","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","a","b","minX","compareMinY","minY","toJSON","fromJSON","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","multiSelect","right2","min","j","right3","_chooseSubtree","level","minArea","Infinity","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","k","p","destNode","maxX","maxY","arr","n","stack","mid"],"sources":["/home/runner/work/Geo-Expert/Geo-Expert/frontend/node_modules/rbush/index.js"],"sourcesContent":["import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}