{"ast":null,"code":"/**\n * @module ol/expr/expression\n */\nimport { ascending } from '../array.js';\nimport { fromString as colorFromString } from '../color.js';\nimport { toSize } from '../size.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\n *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   * `['resolution']` returns the current resolution\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` The current zoom level (WebGL only).\n *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\n *\n * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\n *     `false` otherwise.\n *     Note that for WebGL layers, the hardcoded value `-9999999` is used to distinguish when a property is not defined.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * @param {number} type The type.\n * @return {boolean} The type is one of the specific types (not any or a union type).\n */\nfunction isSpecific(type) {\n  return type in typeNames;\n}\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    if (!isSpecific(type)) {\n      throw new Error(\"literal expressions must have a specific type, got \".concat(typeName(type)));\n    }\n    this.type = type;\n    this.value = value;\n  }\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator) {\n    this.type = type;\n    this.operator = operator;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {boolean} mapState The style uses the map state (view state or time elapsed).\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    mapState: false\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {number} expectedType The expected type.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, expectedType, context) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        if (isType(expectedType, StringType)) {\n          return new LiteralExpression(StringType, encoded ? 'true' : 'false');\n        }\n        if (!includesType(expectedType, BooleanType)) {\n          throw new Error(\"got a boolean, but expected \".concat(typeName(expectedType)));\n        }\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        if (isType(expectedType, SizeType)) {\n          return new LiteralExpression(SizeType, toSize(encoded));\n        }\n        if (isType(expectedType, BooleanType)) {\n          return new LiteralExpression(BooleanType, !!encoded);\n        }\n        if (isType(expectedType, StringType)) {\n          return new LiteralExpression(StringType, encoded.toString());\n        }\n        if (!includesType(expectedType, NumberType)) {\n          throw new Error(\"got a number, but expected \".concat(typeName(expectedType)));\n        }\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        if (isType(expectedType, ColorType)) {\n          return new LiteralExpression(ColorType, colorFromString(encoded));\n        }\n        if (isType(expectedType, BooleanType)) {\n          return new LiteralExpression(BooleanType, !!encoded);\n        }\n        if (!includesType(expectedType, StringType)) {\n          throw new Error(\"got a string, but expected \".concat(typeName(expectedType)));\n        }\n        return new LiteralExpression(StringType, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, expectedType, context);\n  }\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('expected an array of numbers');\n    }\n  }\n  if (isType(expectedType, SizeType)) {\n    if (encoded.length !== 2) {\n      throw new Error(\"expected an array of two values for a size, got \".concat(encoded.length));\n    }\n    return new LiteralExpression(SizeType, encoded);\n  }\n  if (isType(expectedType, ColorType)) {\n    if (encoded.length === 3) {\n      return new LiteralExpression(ColorType, [...encoded, 1]);\n    }\n    if (encoded.length === 4) {\n      return new LiteralExpression(ColorType, encoded);\n    }\n    throw new Error(\"expected an array of 3 or 4 values for a color, got \".concat(encoded.length));\n  }\n  if (!includesType(expectedType, NumberArrayType)) {\n    throw new Error(\"got an array of numbers, but expected \".concat(typeName(expectedType)));\n  }\n  return new LiteralExpression(NumberArrayType, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  LineMetric: 'line-metric',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n  Has: 'has'\n};\n\n/**\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\n *\n * Second argument is the expected type.\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\n  [Ops.Concat]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(StringType)),\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\n  [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Any]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),\n  [Ops.All]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(BooleanType)),\n  [Ops.Not]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType)),\n  [Ops.Equal]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),\n  [Ops.NotEqual]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(AnyType)),\n  [Ops.GreaterThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.LessThan]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Multiply]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),\n  [Ops.Coalesce]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfReturnType),\n  [Ops.Divide]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Add]: createCallExpressionParser(hasArgsCount(2, Infinity), withArgsOfType(NumberType)),\n  [Ops.Subtract]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Clamp]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),\n  [Ops.Mod]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Pow]: createCallExpressionParser(hasArgsCount(2, 2), withArgsOfType(NumberType)),\n  [Ops.Abs]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Floor]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Ceil]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Round]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Sin]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Cos]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Atan]: createCallExpressionParser(hasArgsCount(1, 2), withArgsOfType(NumberType)),\n  [Ops.Sqrt]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(NumberType)),\n  [Ops.Match]: createCallExpressionParser(hasArgsCount(4, Infinity), hasEvenArgs, withMatchArgs),\n  [Ops.Between]: createCallExpressionParser(hasArgsCount(3, 3), withArgsOfType(NumberType)),\n  [Ops.Interpolate]: createCallExpressionParser(hasArgsCount(6, Infinity), hasEvenArgs, withInterpolateArgs),\n  [Ops.Case]: createCallExpressionParser(hasArgsCount(3, Infinity), hasOddArgs, withCaseArgs),\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\n  [Ops.Number]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),\n  [Ops.String]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(AnyType)),\n  [Ops.Array]: createCallExpressionParser(hasArgsCount(1, Infinity), withArgsOfType(NumberType)),\n  [Ops.Color]: createCallExpressionParser(hasArgsCount(1, 4), withArgsOfType(NumberType)),\n  [Ops.Band]: createCallExpressionParser(hasArgsCount(1, 3), withArgsOfType(NumberType)),\n  [Ops.Palette]: createCallExpressionParser(hasArgsCount(2, 2), withPaletteArgs),\n  [Ops.ToString]: createCallExpressionParser(hasArgsCount(1, 1), withArgsOfType(BooleanType | NumberType | StringType | ColorType))\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\n *\n * An argument validator applies various checks to an encoded expression arguments and\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\n */\n\n/**\n * @type {ArgValidator}\n */\nfunction withGetArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const args = new Array(argsCount);\n  for (let i = 0; i < argsCount; ++i) {\n    const key = encoded[i + 1];\n    switch (typeof key) {\n      case 'number':\n        {\n          args[i] = new LiteralExpression(NumberType, key);\n          break;\n        }\n      case 'string':\n        {\n          args[i] = new LiteralExpression(StringType, key);\n          break;\n        }\n      default:\n        {\n          throw new Error(\"expected a string key or numeric array index for a get operation, got \".concat(key));\n        }\n    }\n    if (i === 0) {\n      context.properties.add(String(key));\n    }\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withVarArgs(encoded, returnType, context) {\n  const name = encoded[1];\n  if (typeof name !== 'string') {\n    throw new Error('expected a string argument for var operation');\n  }\n  context.variables.add(name);\n  return [new LiteralExpression(StringType, name)];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesFeatureId(encoded, returnType, context) {\n  context.featureId = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesGeometryType(encoded, returnType, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesMapState(encoded, returnType, context) {\n  context.mapState = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withNoArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(\"expected no arguments for \".concat(operation, \" operation\"));\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction hasArgsCount(minArgs, maxArgs) {\n  return function (encoded, returnType, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\"expected \".concat(minArgs, \" argument\").concat(plural, \" for \").concat(operation, \", got \").concat(argCount));\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range = maxArgs === Infinity ? \"\".concat(minArgs, \" or more\") : \"\".concat(minArgs, \" to \").concat(maxArgs);\n      throw new Error(\"expected \".concat(range, \" arguments for \").concat(operation, \", got \").concat(argCount));\n    }\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withArgsOfReturnType(encoded, returnType, context) {\n  const argCount = encoded.length - 1;\n  /**\n   * @type {Array<Expression>}\n   */\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    const expression = parse(encoded[i + 1], returnType, context);\n    args[i] = expression;\n  }\n  return args;\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsOfType(argType) {\n  return function (encoded, returnType, context) {\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], argType, context);\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasOddArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\"expected an odd number of arguments for \".concat(operation, \", got \").concat(argCount, \" instead\"));\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasEvenArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\"expected an even number of arguments for operation \".concat(operation, \", got \").concat(argCount, \" instead\"));\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withMatchArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const inputType = StringType | NumberType | BooleanType;\n  const input = parse(encoded[1], inputType, context);\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    try {\n      const match = parse(encoded[i + 2], input.type, context);\n      args[i] = match;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i + 1, \" of match expression: \").concat(err.message));\n    }\n    try {\n      const output = parse(encoded[i + 3], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i + 2, \" of match expression: \").concat(err.message));\n    }\n  }\n  return [input, ...args, fallback];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInterpolateArgs(encoded, returnType, context) {\n  const interpolationType = encoded[1];\n  /**\n   * @type {number}\n   */\n  let base;\n  switch (interpolationType[0]) {\n    case 'linear':\n      base = 1;\n      break;\n    case 'exponential':\n      const b = interpolationType[1];\n      if (typeof b !== 'number' || b <= 0) {\n        throw new Error(\"expected a number base for exponential interpolation\" + \", got \".concat(JSON.stringify(b), \" instead\"));\n      }\n      base = b;\n      break;\n    default:\n      throw new Error(\"invalid interpolation type: \".concat(JSON.stringify(interpolationType)));\n  }\n  const interpolation = new LiteralExpression(NumberType, base);\n  let input;\n  try {\n    input = parse(encoded[2], NumberType, context);\n  } catch (err) {\n    throw new Error(\"failed to parse argument 1 in interpolate expression: \".concat(err.message));\n  }\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    try {\n      const stop = parse(encoded[i + 3], NumberType, context);\n      args[i] = stop;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i + 2, \" for interpolate expression: \").concat(err.message));\n    }\n    try {\n      const output = parse(encoded[i + 4], returnType, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i + 3, \" for interpolate expression: \").concat(err.message));\n    }\n  }\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withCaseArgs(encoded, returnType, context) {\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    try {\n      const condition = parse(encoded[i + 1], BooleanType, context);\n      args[i] = condition;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i, \" of case expression: \").concat(err.message));\n    }\n    try {\n      const output = parse(encoded[i + 2], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\"failed to parse argument \".concat(i + 1, \" of case expression: \").concat(err.message));\n    }\n  }\n  args[args.length - 1] = fallback;\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInArgs(encoded, returnType, context) {\n  let haystack = encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\"the second argument for the \\\"in\\\" operator must be an array\");\n  }\n  /**\n   * @type {number}\n   */\n  let needleType;\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\"for the \\\"in\\\" operator, a string array should be wrapped in a \\\"literal\\\" operator to disambiguate from expressions\");\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\"failed to parse \\\"in\\\" expression: the literal operator must be followed by an array\");\n    }\n    haystack = haystack[1];\n    needleType = StringType;\n  } else {\n    needleType = NumberType;\n  }\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    try {\n      const arg = parse(haystack[i], needleType, context);\n      args[i] = arg;\n    } catch (err) {\n      throw new Error(\"failed to parse haystack item \".concat(i, \" for \\\"in\\\" expression: \").concat(err.message));\n    }\n  }\n  const needle = parse(encoded[1], needleType, context);\n  return [needle, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withPaletteArgs(encoded, returnType, context) {\n  let index;\n  try {\n    index = parse(encoded[1], NumberType, context);\n  } catch (err) {\n    throw new Error(\"failed to parse first argument in palette expression: \".concat(err.message));\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('the second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    let color;\n    try {\n      color = parse(colors[i], ColorType, context);\n    } catch (err) {\n      throw new Error(\"failed to parse color at index \".concat(i, \" in palette expression: \").concat(err.message));\n    }\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\"the palette color at index \".concat(i, \" must be a literal value\"));\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\n * to return the parsed arguments.\n * @return {Parser} The parser.\n */\nfunction createCallExpressionParser() {\n  for (var _len2 = arguments.length, validators = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    validators[_key2] = arguments[_key2];\n  }\n  return function (encoded, returnType, context) {\n    const operator = encoded[0];\n\n    /**\n     * @type {Array<Expression>}\n     */\n    let args;\n    for (let i = 0; i < validators.length; i++) {\n      const parsed = validators[i](encoded, returnType, context);\n      if (i == validators.length - 1) {\n        if (!parsed) {\n          throw new Error('expected last argument validator to return the parsed args');\n        }\n        args = parsed;\n      }\n    }\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {number} returnType The expected return type of the call expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, returnType, context) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(\"unknown operator: \".concat(operator));\n  }\n  return parser(encoded, returnType, context);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */type.substring(5);\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(/** @type {import(\"../geom/GeometryCollection.js\").default} */geometry.getGeometries()[0]);\n    default:\n      return '';\n  }\n}","map":{"version":3,"names":["ascending","fromString","colorFromString","toSize","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","SizeType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","isSpecific","type","typeName","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","Error","concat","CallExpression","operator","_len","arguments","args","Array","_key","newParsingContext","variables","Set","properties","featureId","geometryType","mapState","parse","encoded","expectedType","context","toString","isArray","parseCallExpression","item","Ops","Get","Var","Concat","GeometryType","LineMetric","Any","All","Not","Resolution","Zoom","Time","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","Between","Interpolate","Coalesce","Case","In","String","Color","Id","Band","Palette","ToString","Has","parsers","createCallExpressionParser","hasArgsCount","Infinity","withGetArgs","withVarArgs","usesFeatureId","withNoArgs","withArgsOfType","usesGeometryType","usesMapState","withArgsOfReturnType","hasEvenArgs","withMatchArgs","withInterpolateArgs","hasOddArgs","withCaseArgs","withInArgs","withPaletteArgs","returnType","argsCount","i","key","add","name","operation","minArgs","maxArgs","argCount","plural","range","expression","argType","inputType","input","fallback","match","err","message","output","interpolationType","base","b","JSON","stringify","interpolation","stop","condition","haystack","needleType","arg","needle","index","colors","parsedColors","color","_len2","validators","_key2","parsed","parser","computeGeometryType","geometry","getType","substring","getGeometries"],"sources":["/home/runner/work/Geo-Expert/Geo-Expert/frontend/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\nimport {ascending} from '../array.js';\nimport {fromString as colorFromString} from '../color.js';\nimport {toSize} from '../size.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\n *\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\n *\n * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\n *   * `['get', attributeName]` fetches a feature property value, similar to `feature.get('attributeName')`.\n *   * `['get', attributeName, keyOrArrayIndex, ...]` (Canvas only) Access nested properties and array items of a\n *     feature property. The result is `undefined` when there is nothing at the specified key or index.\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\n *   * `['resolution']` returns the current resolution\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` The current zoom level (WebGL only).\n *   * `['line-metric']` returns the M component of the current point on a line (WebGL only); in case where the geometry layout of the line\n *      does not contain an M component (e.g. XY or XYZ), 0 is returned; 0 is also returned for geometries other than lines.\n *      Please note that the M component will be linearly interpolated between the two points composing a segment.\n *\n * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\n *     (Canvas only).\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\n *     (Canvas only).\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\n *     (Canvas only).\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['has', attributeName, keyOrArrayIndex, ...]` returns `true` if feature properties include the (nested) key `attributeName`,\n *     `false` otherwise.\n *     Note that for WebGL layers, the hardcoded value `-9999999` is used to distinguish when a property is not defined.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4 (WebGL only).\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const SizeType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n  [SizeType]: 'size',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * @param {number} type The type.\n * @return {boolean} The type is one of the specific types (not any or a union type).\n */\nfunction isSpecific(type) {\n  return type in typeNames;\n}\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    if (!isSpecific(type)) {\n      throw new Error(\n        `literal expressions must have a specific type, got ${typeName(type)}`,\n      );\n    }\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n * @property {boolean} featureId The style uses the feature id.\n * @property {boolean} geometryType The style uses the feature geometry type.\n * @property {boolean} mapState The style uses the map state (view state or time elapsed).\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n    featureId: false,\n    geometryType: false,\n    mapState: false,\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {number} expectedType The expected type.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, expectedType, context) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded ? 'true' : 'false');\n      }\n      if (!includesType(expectedType, BooleanType)) {\n        throw new Error(\n          `got a boolean, but expected ${typeName(expectedType)}`,\n        );\n      }\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      if (isType(expectedType, SizeType)) {\n        return new LiteralExpression(SizeType, toSize(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (isType(expectedType, StringType)) {\n        return new LiteralExpression(StringType, encoded.toString());\n      }\n      if (!includesType(expectedType, NumberType)) {\n        throw new Error(`got a number, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      if (isType(expectedType, ColorType)) {\n        return new LiteralExpression(ColorType, colorFromString(encoded));\n      }\n      if (isType(expectedType, BooleanType)) {\n        return new LiteralExpression(BooleanType, !!encoded);\n      }\n      if (!includesType(expectedType, StringType)) {\n        throw new Error(`got a string, but expected ${typeName(expectedType)}`);\n      }\n      return new LiteralExpression(StringType, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, expectedType, context);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('expected an array of numbers');\n    }\n  }\n\n  if (isType(expectedType, SizeType)) {\n    if (encoded.length !== 2) {\n      throw new Error(\n        `expected an array of two values for a size, got ${encoded.length}`,\n      );\n    }\n    return new LiteralExpression(SizeType, encoded);\n  }\n\n  if (isType(expectedType, ColorType)) {\n    if (encoded.length === 3) {\n      return new LiteralExpression(ColorType, [...encoded, 1]);\n    }\n    if (encoded.length === 4) {\n      return new LiteralExpression(ColorType, encoded);\n    }\n    throw new Error(\n      `expected an array of 3 or 4 values for a color, got ${encoded.length}`,\n    );\n  }\n\n  if (!includesType(expectedType, NumberArrayType)) {\n    throw new Error(\n      `got an array of numbers, but expected ${typeName(expectedType)}`,\n    );\n  }\n\n  return new LiteralExpression(NumberArrayType, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Get: 'get',\n  Var: 'var',\n  Concat: 'concat',\n  GeometryType: 'geometry-type',\n  LineMetric: 'line-metric',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Zoom: 'zoom',\n  Time: 'time',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n  Between: 'between',\n  Interpolate: 'interpolate',\n  Coalesce: 'coalesce',\n  Case: 'case',\n  In: 'in',\n  Number: 'number',\n  String: 'string',\n  Array: 'array',\n  Color: 'color',\n  Id: 'id',\n  Band: 'band',\n  Palette: 'palette',\n  ToString: 'to-string',\n  Has: 'has',\n};\n\n/**\n * @typedef {function(Array, number, ParsingContext):Expression} Parser\n *\n * Second argument is the expected type.\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),\n  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),\n  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),\n  [Ops.Concat]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(StringType),\n  ),\n  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),\n  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),\n  [Ops.Resolution]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Zoom]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Time]: createCallExpressionParser(usesMapState, withNoArgs),\n  [Ops.Any]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.All]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Not]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType),\n  ),\n  [Ops.Equal]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.NotEqual]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.GreaterThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThan]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.LessThanOrEqualTo]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Multiply]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Coalesce]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfReturnType,\n  ),\n  [Ops.Divide]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Add]: createCallExpressionParser(\n    hasArgsCount(2, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Subtract]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Clamp]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Mod]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Pow]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Abs]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Floor]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Ceil]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Round]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sin]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Cos]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Atan]: createCallExpressionParser(\n    hasArgsCount(1, 2),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Sqrt]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Match]: createCallExpressionParser(\n    hasArgsCount(4, Infinity),\n    hasEvenArgs,\n    withMatchArgs,\n  ),\n  [Ops.Between]: createCallExpressionParser(\n    hasArgsCount(3, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Interpolate]: createCallExpressionParser(\n    hasArgsCount(6, Infinity),\n    hasEvenArgs,\n    withInterpolateArgs,\n  ),\n  [Ops.Case]: createCallExpressionParser(\n    hasArgsCount(3, Infinity),\n    hasOddArgs,\n    withCaseArgs,\n  ),\n  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),\n  [Ops.Number]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.String]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(AnyType),\n  ),\n  [Ops.Array]: createCallExpressionParser(\n    hasArgsCount(1, Infinity),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Color]: createCallExpressionParser(\n    hasArgsCount(1, 4),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Band]: createCallExpressionParser(\n    hasArgsCount(1, 3),\n    withArgsOfType(NumberType),\n  ),\n  [Ops.Palette]: createCallExpressionParser(\n    hasArgsCount(2, 2),\n    withPaletteArgs,\n  ),\n  [Ops.ToString]: createCallExpressionParser(\n    hasArgsCount(1, 1),\n    withArgsOfType(BooleanType | NumberType | StringType | ColorType),\n  ),\n};\n\n/**\n * @typedef {function(Array<EncodedExpression>, number, ParsingContext):Array<Expression>|void} ArgValidator\n *\n * An argument validator applies various checks to an encoded expression arguments and\n * returns the parsed arguments if any.  The second argument is the return type of the call expression.\n */\n\n/**\n * @type {ArgValidator}\n */\nfunction withGetArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n  const args = new Array(argsCount);\n  for (let i = 0; i < argsCount; ++i) {\n    const key = encoded[i + 1];\n    switch (typeof key) {\n      case 'number': {\n        args[i] = new LiteralExpression(NumberType, key);\n        break;\n      }\n      case 'string': {\n        args[i] = new LiteralExpression(StringType, key);\n        break;\n      }\n      default: {\n        throw new Error(\n          `expected a string key or numeric array index for a get operation, got ${key}`,\n        );\n      }\n    }\n    if (i === 0) {\n      context.properties.add(String(key));\n    }\n  }\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withVarArgs(encoded, returnType, context) {\n  const name = encoded[1];\n  if (typeof name !== 'string') {\n    throw new Error('expected a string argument for var operation');\n  }\n  context.variables.add(name);\n\n  return [new LiteralExpression(StringType, name)];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesFeatureId(encoded, returnType, context) {\n  context.featureId = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesGeometryType(encoded, returnType, context) {\n  context.geometryType = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction usesMapState(encoded, returnType, context) {\n  context.mapState = true;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withNoArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @return {ArgValidator} The argument validator\n */\nfunction hasArgsCount(minArgs, maxArgs) {\n  return function (encoded, returnType, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      const range =\n        maxArgs === Infinity\n          ? `${minArgs} or more`\n          : `${minArgs} to ${maxArgs}`;\n      throw new Error(\n        `expected ${range} arguments for ${operation}, got ${argCount}`,\n      );\n    }\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withArgsOfReturnType(encoded, returnType, context) {\n  const argCount = encoded.length - 1;\n  /**\n   * @type {Array<Expression>}\n   */\n  const args = new Array(argCount);\n  for (let i = 0; i < argCount; ++i) {\n    const expression = parse(encoded[i + 1], returnType, context);\n    args[i] = expression;\n  }\n  return args;\n}\n\n/**\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgsOfType(argType) {\n  return function (encoded, returnType, context) {\n    const argCount = encoded.length - 1;\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], argType, context);\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasOddArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 0) {\n    throw new Error(\n      `expected an odd number of arguments for ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction hasEvenArgs(encoded, returnType, context) {\n  const operation = encoded[0];\n  const argCount = encoded.length - 1;\n  if (argCount % 2 === 1) {\n    throw new Error(\n      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`,\n    );\n  }\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withMatchArgs(encoded, returnType, context) {\n  const argsCount = encoded.length - 1;\n\n  const inputType = StringType | NumberType | BooleanType;\n\n  const input = parse(encoded[1], inputType, context);\n\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(argsCount - 2);\n  for (let i = 0; i < argsCount - 2; i += 2) {\n    try {\n      const match = parse(encoded[i + 2], input.type, context);\n      args[i] = match;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of match expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 3], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} of match expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [input, ...args, fallback];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInterpolateArgs(encoded, returnType, context) {\n  const interpolationType = encoded[1];\n  /**\n   * @type {number}\n   */\n  let base;\n  switch (interpolationType[0]) {\n    case 'linear':\n      base = 1;\n      break;\n    case 'exponential':\n      const b = interpolationType[1];\n      if (typeof b !== 'number' || b <= 0) {\n        throw new Error(\n          `expected a number base for exponential interpolation` +\n            `, got ${JSON.stringify(b)} instead`,\n        );\n      }\n      base = b;\n      break;\n    default:\n      throw new Error(\n        `invalid interpolation type: ${JSON.stringify(interpolationType)}`,\n      );\n  }\n\n  const interpolation = new LiteralExpression(NumberType, base);\n\n  let input;\n  try {\n    input = parse(encoded[2], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse argument 1 in interpolate expression: ${err.message}`,\n    );\n  }\n\n  const args = new Array(encoded.length - 3);\n  for (let i = 0; i < args.length; i += 2) {\n    try {\n      const stop = parse(encoded[i + 3], NumberType, context);\n      args[i] = stop;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 4], returnType, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`,\n      );\n    }\n  }\n\n  return [interpolation, input, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withCaseArgs(encoded, returnType, context) {\n  const fallback = parse(encoded[encoded.length - 1], returnType, context);\n\n  const args = new Array(encoded.length - 1);\n  for (let i = 0; i < args.length - 1; i += 2) {\n    try {\n      const condition = parse(encoded[i + 1], BooleanType, context);\n      args[i] = condition;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i} of case expression: ${err.message}`,\n      );\n    }\n    try {\n      const output = parse(encoded[i + 2], fallback.type, context);\n      args[i + 1] = output;\n    } catch (err) {\n      throw new Error(\n        `failed to parse argument ${i + 1} of case expression: ${err.message}`,\n      );\n    }\n  }\n\n  args[args.length - 1] = fallback;\n  return args;\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withInArgs(encoded, returnType, context) {\n  let haystack = encoded[2];\n  if (!Array.isArray(haystack)) {\n    throw new Error(\n      `the second argument for the \"in\" operator must be an array`,\n    );\n  }\n  /**\n   * @type {number}\n   */\n  let needleType;\n  if (typeof haystack[0] === 'string') {\n    if (haystack[0] !== 'literal') {\n      throw new Error(\n        `for the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions`,\n      );\n    }\n    if (!Array.isArray(haystack[1])) {\n      throw new Error(\n        `failed to parse \"in\" expression: the literal operator must be followed by an array`,\n      );\n    }\n    haystack = haystack[1];\n    needleType = StringType;\n  } else {\n    needleType = NumberType;\n  }\n\n  const args = new Array(haystack.length);\n  for (let i = 0; i < args.length; i++) {\n    try {\n      const arg = parse(haystack[i], needleType, context);\n      args[i] = arg;\n    } catch (err) {\n      throw new Error(\n        `failed to parse haystack item ${i} for \"in\" expression: ${err.message}`,\n      );\n    }\n  }\n\n  const needle = parse(encoded[1], needleType, context);\n  return [needle, ...args];\n}\n\n/**\n * @type {ArgValidator}\n */\nfunction withPaletteArgs(encoded, returnType, context) {\n  let index;\n  try {\n    index = parse(encoded[1], NumberType, context);\n  } catch (err) {\n    throw new Error(\n      `failed to parse first argument in palette expression: ${err.message}`,\n    );\n  }\n  const colors = encoded[2];\n  if (!Array.isArray(colors)) {\n    throw new Error('the second argument of palette must be an array');\n  }\n  const parsedColors = new Array(colors.length);\n  for (let i = 0; i < parsedColors.length; i++) {\n    let color;\n    try {\n      color = parse(colors[i], ColorType, context);\n    } catch (err) {\n      throw new Error(\n        `failed to parse color at index ${i} in palette expression: ${err.message}`,\n      );\n    }\n    if (!(color instanceof LiteralExpression)) {\n      throw new Error(\n        `the palette color at index ${i} must be a literal value`,\n      );\n    }\n    parsedColors[i] = color;\n  }\n  return [index, ...parsedColors];\n}\n\n/**\n * @param {Array<ArgValidator>} validators A chain of argument validators.  The last validator is expected\n * to return the parsed arguments.\n * @return {Parser} The parser.\n */\nfunction createCallExpressionParser(...validators) {\n  return function (encoded, returnType, context) {\n    const operator = encoded[0];\n\n    /**\n     * @type {Array<Expression>}\n     */\n    let args;\n    for (let i = 0; i < validators.length; i++) {\n      const parsed = validators[i](encoded, returnType, context);\n      if (i == validators.length - 1) {\n        if (!parsed) {\n          throw new Error(\n            'expected last argument validator to return the parsed args',\n          );\n        }\n        args = parsed;\n      }\n    }\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {number} returnType The expected return type of the call expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, returnType, context) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`unknown operator: ${operator}`);\n  }\n  return parser(encoded, returnType, context);\n}\n\n/**\n * Returns a simplified geometry type suited for the `geometry-type` operator\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\n */\nexport function computeGeometryType(geometry) {\n  if (!geometry) {\n    return '';\n  }\n  const type = geometry.getType();\n  switch (type) {\n    case 'Point':\n    case 'LineString':\n    case 'Polygon':\n      return type;\n    case 'MultiPoint':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\n    case 'Circle':\n      return 'Polygon';\n    case 'GeometryCollection':\n      return computeGeometryType(\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries()[0],\n      );\n    default:\n      return '';\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,SAAS,QAAO,aAAa;AACrC,SAAQC,UAAU,IAAIC,eAAe,QAAO,aAAa;AACzD,SAAQC,MAAM,QAAO,YAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,MAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,MAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,MAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,MAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,MAAMO,QAAQ,GAAG,CAAC,IAAIP,QAAQ,EAAE;AACvC,OAAO,MAAMQ,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,QAAQ,CAAC,GAAG,CAAC;AAEhD,MAAMW,SAAS,GAAG;EAChB,C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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}